
# Yeast Aneuploidy Analysis
# 
# This application takes exported data files from the 7900HT qPCR instrument and returns graphs of the "absolute" karoytpe as
# described in: Pavelka N, Rancati G, Zhu J, Bradford W, Saraf A, Florens L, Sanderson B, Li R. 
# Aneuploidy confers quantitative proteome changes and phenotypic variation in budding yeast. Nature. 2010;468:321â€“325
# 
# Ct values (a log scale measurement of relative DNA quantity) are measured for two seperate sites on each of yeasts 16 
# chromosomes. Each assay is normalized to the Ct results from a known Wildtype strain of yeast.  Each sample is then scaled to
# the median Ct value across all the assays for a given sample. To determine the "absolute" katotype value, prior knowledge of
# of the base ploidy of a strain is required. This absolute vs relative distinction just involves a rescaling of the data.
# The look of the graphs don't change, they are just more clearly labled.  This application takes the exported results from an SDS
# file generated on the 7900HT, organizes the data into a tidy format, allows the user to set their wildtype strain and the 
# base ploidy of their samples, and returns graphs of the resulting sample karotypes.  It should be able to robustly handle 
# varying plate layouts as long as your samples and assays are correctly labled on the instrument.
#
# 
# The intent is to load new files, but for conveninces of grading I've added a default example file.
# The app should default to opening "example.txt" a file with samples labled 1, 2, 3, and wt.  Samples 1 and 2 have a base ploidy
# of 2.  Samples 3 and wt have a base ploidy of 1. wt is the intended wt control.  The wt graph has been set to 1 mathmatically
# so the graph of it is a little unessessary, but was easier than trying to make it conditinally displayed.
# 
# With a little tweaking datasetInput could be generalizable to parsing exported SDS files for other qPCR experiments.

library(shiny)
library(dplyr)
library(ggplot2)
library(tidyr)

shinyServer(function(input, output, clientData, session) {
  
  ## Read in raw file that is generated by the instrument and tidy up the data so it is easier to work with
  datasetInput <- reactive({
    
    infile <- input$sdsfile
    
    ## Check if User has imported a File yet
    if (is.null(infile)) {
      infile <- list()
      infile$datapath <- "example.txt"
    }
    
    table <- read.csv(infile$datapath, skip = 10, header = TRUE, sep = "\t", as.is = TRUE )
    
    ## Tidying detector names- 
    ##First is for easy use of seperate function with out specific assays
    table$Detector.Name <- sub("^(.{5})(.{2})$", "\\1-\\2", table$Detector.Name)
    
    ##  2nd to fix legacy labeling issue on our qPCR instrument
    table$Detector.Name <- sub("[bc]$", "a", table$Detector.Name)
    
    ## Removing rows with out data, grouping importaint columns and formating their correct type.
    filter(table, !(Well %in% c("Slope", "Y-Intercept", "R^2", "Well", "NAP", "")))%>%
      select(Well, Sample.Name, Detector.Name, Ct, Ct.Median)%>%
      separate(Detector.Name, c("chr", "arm"), sep = "-")%>%
      mutate(Sample.Name = as.factor(Sample.Name), 
        chr = as.factor(chr), 
        arm = as.factor(arm), 
        Ct = as.numeric(Ct), 
        Ct.Median = as.numeric(Ct.Median)) -> table
    return(table)
  })
  
  ## Outputting the reformated data
  output$view <- renderTable({
    datasetInput()
  })
  
  ## Observing values for the reactive UI elements pulled from the uploaded data
  observe({
    samples <- datasetInput()$Sample.Name
    updateSelectInput(session, "wt", choices = levels(samples))
    updateSliderInput(session, "slider1", label = paste(as.character(levels(samples)[1]), "base ploidy"), value = NA)
    updateSliderInput(session, "slider2", label = paste(as.character(levels(samples)[2]), "base ploidy"), value = NA)
    updateSliderInput(session, "slider3", label = paste(as.character(levels(samples)[3]), "base ploidy"), value = NA)
    updateSliderInput(session, "slider4", label = paste(as.character(levels(samples)[4]), "base ploidy"), value = NA)
  })
  
  ## Performing the Normalization reqired to converted the measured Ct values into relative expression values.
  normalData <- reactive({
    intable <- datasetInput()
    samples <- datasetInput()$Sample.Name
    group_by(intable, chr, arm)%>%
      mutate(dCt = Ct.Median - Ct.Median[Sample.Name == input$wt ])%>%
      ungroup()%>%
      group_by(Sample.Name)%>%
      mutate(samp.med = median(dCt))%>%
      ungroup() -> intable
    
    ## There has probably got to be more elegant approach to adding specific base values for each Sample.Name, 
    ## but I kludge it up by making seperate objects for each Sample.Name, adding the base value, then putting them back together.
    s1 <- mutate(filter(intable, Sample.Name == levels(samples)[1]), base = input$slider1)
    s2 <- mutate(filter(intable, Sample.Name == levels(samples)[2]), base = input$slider2)
    s3 <- mutate(filter(intable, Sample.Name == levels(samples)[3]), base = input$slider3)
    s4 <- mutate(filter(intable, Sample.Name == levels(samples)[4]), base = input$slider4)
    
    outtable <- rbind(s1, s2, s3, s4)
    
    
    ## The math the math for generating our "absolute" quantitites startin from Ct values.
    mutate(outtable, ddCt = dCt - samp.med)%>%
      group_by(chr, Sample.Name)%>%
      mutate(rel.ddCt = mean(ddCt), rel.sem = sd(ddCt)/sqrt(2))%>%
      mutate(rel.up = rel.ddCt + rel.sem, rel.low = rel.ddCt - rel.sem)%>%
      mutate(rel.fold = 2^rel.ddCt, rel.up.bar = 2^rel.up, rel.low.bar = 2^rel.low)%>%
      mutate(abs.fold = rel.fold * base, abs.up.bar = rel.up.bar * base, abs.low.bar = rel.low.bar* base)%>%
      select(-arm, -chr)%>%
      distinct() ->  outtable
    
    return(outtable)
    
  })
  
  
  ## Outputing Karyotype plots
  output$plot1 <- renderPlot({
    data <-normalData()
    plot <- ggplot(filter(data, Sample.Name == levels(data$Sample.Name)[1]), aes(x = chr, y =abs.fold)) + 
      geom_bar(stat = "identity") +
      geom_errorbar(aes(y = abs.fold, ymax = abs.up.bar, ymin = abs.low.bar)) +
      ggtitle(levels(data$Sample.Name)[1])
    return(plot)
  })
  
  output$plot2 <- renderPlot({
    data <-normalData()
    plot <- ggplot(filter(data, Sample.Name == levels(data$Sample.Name)[2]), aes(x = chr, y =abs.fold)) + 
      geom_bar(stat = "identity") +
      geom_errorbar(aes(y = abs.fold, ymax = abs.up.bar, ymin = abs.low.bar)) +
      ggtitle(levels(data$Sample.Name)[2])
    return(plot)
  })
  
  output$plot3 <- renderPlot({
    data <-normalData()
    plot <- ggplot(filter(data, Sample.Name == levels(data$Sample.Name)[3]), aes(x = chr, y =abs.fold)) + 
      geom_bar(stat = "identity") +
      geom_errorbar(aes(y = abs.fold, ymax = abs.up.bar, ymin = abs.low.bar)) +
      ggtitle(levels(data$Sample.Name)[3])
    return(plot)
  })
  
  output$plot4 <- renderPlot({
    data <-normalData()
    plot <- ggplot(filter(data, Sample.Name == levels(data$Sample.Name)[4]), aes(x = chr, y =rel.fold)) + 
      geom_bar(stat = "identity") +
      geom_errorbar(aes(y = rel.fold, ymax = rel.up.bar, ymin = rel.low.bar)) +
      ggtitle(levels(data$Sample.Name)[4])
    return(plot)
  })  
})



